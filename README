C3BT: Compact Clustered Crit-Bit Tree

Introduction
------------
Take Crit-Bit Tree (as CBT hereafter), squeeze the nodes into cache-line sized
cells, and we get C3BT.  So if you like, you may read C3BT as "Cache-Conscious
Crit-Bit Tree".

Don't know what a CBT is?  Look here: http://cr.yp.to/critbit.html

In the 32-bit standard layout, each cell is 64 bytes and contains up to 8 crit-
bit nodes.  It can index keys up to 256 bits long.  The LP64 version (TODO) uses
128 byte cells each can hold 9 nodes and supports 64K-bit keys.

C3BT also extends the functionality of CBT.  Its API should be familiar to
binary search tree users: INIT, DESTROY, ADD, REMOVE, FIND, FIRST, LAST, NEXT,
and PREV.  Keys can be fixed-length bit-string, zero-terminated string, 32 and
64 bit integers signed and unsigned, all with native ordering.  Custom or
composite key data types can be supported by a custom "bitops" -- like a
comparator to a BST.

Most implementations of BST embed index nodes in user objects; with C3BT, the
index is separate and you add/remove user objects by reference.  The reason is
that CBT node uses a crit-bit number to bisect the remaining key value space,
which is not a part of user object (in comparison, BSTs use the user object as
separator to bisect the remaining key set).  A separate index can be created and
destroyed independently; some applications may prefer this flexibility.  From
users' point of view, there is no difference in the API.

A standard binary tree may not be known for good memory efficiency or reference
locality and these are where C3BT has improved through its cache friendly layout
scheme.  You get efficiency, performance and flexibility:

    - Memory allocation is per-cell; overhead is low.
    - Index access is fast.
    - User objects are not diluted by index; this can make a difference if user
      object is small and densely stored.
    - Index can be created and destroyed freely.

Besides, C3BT uses parent pointers on the cell level but not in the nodes.  This
speeds up iteration with little cost of space.

The author hopes C3BT can help popularize CBT as an alternative to BSTs, T-Tree
and in-memory B-Tree.  CBT works on the fundamental representation of data, and
playing with bits is fun.

Build
-----
This version supports only GCC on 32-bit linux.

Just type "make". There are 3 files: c3bt.h, c3bt.c and c3bt-main.c.  The first
two are meant to be dropped in your project, and the third is an ugly ad-hoc
tester.

The code is shipped with statistics enabled.  If you don't need it, undefine
C3BT_STATS in c3bt.h.

If all you need is an associative array, you may define C3BT_FEATURE_MIN to
reduce code size.  You can lookup an user object by a key value; you can still
iterate through the set, but the ordering is likely wrong.  You need to treat
your keys as bit-strings in this case.

Usage
-----
C3BT can be used in two ways, hence two init functions are provided.  One is
c3bt_init() where you specify the key's data type, offset in your object and its
length.  The other, c3bt_init_bitops(), allows you to install a bitops function
to support custom key types.  All the details about the key, including its
source of bits and length are handled by the bitops function.

After initialization, you may use c3bt_add() to add some user objects, and
c3bt_remove() to remove them.  Again, these are all by reference: "add" won't
create or copy a object and "remove" won't free any.

Once you have some objects in the tree, there are various c3bt_find() functions
that can be used to find an object by key value, and c3bt_first(), c3bt_last(),
c3bt_next() and c3bt_prev() can help iterate through all the objects that are
indexed by the tree.

Bitops
------
Bitops, meaning "bit operations", is a function specific to a key type.  Its job
is to answer three kinds of queries about the key:

 1. Get bit: what is the key's bit value at position N?
 2. Crit-bit: given two keys, which bit is the first bit where they differ?  Or,
    how long is their common prefix?
 3. Equality test: are the two keys equal?

Query #3 is covered by #2 because if we can't find a differing bit (up to the
maximum key length), the keys are equal.  So bitops needs to implement two
functions: get_bit and crit_bit.

The prototype is defined as:
    int bitops(int req, void *key1, void *key2);

"req" is the request number.  When req>=0, it's a get_bit query.  Bitops should
return the bit at position "req" of key1.  Key2 is ignored.

If req<0, it's a crit_bit query.  Bitops should find the differing bit and
return its position.  If such a bit can't be found, return -1 to report they are
equal.  The maximum number of bits to be compared can be derived from (-req-1).

Bit position is numbered in "written order", that is, the order that you would
write it on paper.  For example, 32-bit integers' MSB is bit #0 and LSB is bit
#31; for a string, character at byte offset n's MSB is #n*8, and its LSB is
#n*8+7.  You may call it pure big-endian.

Bitops is called frequently, especially the get_bit query.  You should make it
as short and fast as possible.  If you plan to use only one key type, you may
consider inlining it to eliminate the function call overhead.

# vim: set et ts=4 tw=80 spell spl=en_us:

