C3BT: Compact Clustered Crit-Bit Tree

Introduction
------------
Take Crit-Bit Tree (as CBT hereafter), squeeze the nodes into cache line sized
cells, and we get C3BT.  So if you like, you may read C3BT as "Cache-Conscious
Crit-Bit Tree".

Don't know what a CBT is?  Look here: http://cr.yp.to/critbit.html

In the 32-bit standard layout, each cell is 64B and contains up to 8 crit-bit
nodes.  It can index keys up to 256 bits long.  The 64-bit version (TODO) uses
128B cells each can hold 9 nodes and supports 64K bits keys.

C3BT also extends the functionality of CBT.  Its API should be familiar to
binary search tree users and the key is not limited to string or bit-string; it
supports common key data types with correct ordering.  You may easily extend the
data types by writing a custom "bitops" -- like a comparator to a BST.

Most implementations of BST embed index nodes in user objects, but C3BT (like
CBT) is a separate index, you add/remove user objects by reference.  This is due
to the nature of CBT: each node bisects the remaining value space by a crit-bit,
rather than using the key as a separator to bisect the key set like a BST does.
But since it's clustered in a cache friendly way, you get both performance and
flexibility:

    - Memory allocation overhead of the index is low.
    - Index access is fast.
    - User objects are not diluted by index; this can make a difference if user
      object is small. 
    - Index can be created and destroyed dynamically and freely.

The author hopes C3BT can help popularize CBT as an alternative to BSTs, T-Tree
and in-memory B-Tree.  CBT works on the fundamental representation of data, and
playing with bits is fun.

Build
-----
Just type "make". There are 3 files: c3bt.h, c3bt.c and c3bt-main.c.  The first
two are meant to be dropped in your project, and the third is an ugly ad-hoc
tester.

This version supports only GCC and 32-bit linux.

Quick User Guide
----------------
<<to be continued>>

# vim: set et ts=4 tw=80 spell spl=en_us:

